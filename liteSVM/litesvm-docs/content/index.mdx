---
title: LiteSVM - Lightning-fast Solana Testing
description: Lightning-fast Solana program testing with an in-process VM. Test your programs 10x faster without network overhead or validator processes.
---

import { Callout } from 'fumadocs-ui/components/callout';
import { Tab, Tabs } from 'fumadocs-ui/components/tabs';
import { Steps, Step } from 'fumadocs-ui/components/steps';

<div className="flex flex-col items-center justify-center text-center px-6 py-12 md:py-16">
  <h1 className="mb-4 text-5xl font-bold bg-gradient-to-r from-[#14F195] to-[#9945FF] bg-clip-text text-transparent">
    LiteSVM
  </h1>
  
  <div className="text-xl text-fd-muted-foreground mb-8 max-w-2xl">
    Lightning-fast Solana program testing with an in-process VM. 
    Test your programs 10x faster without network overhead or validator processes.
  </div>
  
  <div className="flex gap-4 flex-wrap justify-center">
    <a
      href="/docs"
      className="px-6 py-3 bg-gradient-to-r from-[#14F195] to-[#9945FF] text-black font-semibold rounded-lg hover:opacity-90 transition-opacity"
    >
      Get Started
    </a>
  </div>
</div>

## Overview

LiteSVM is a lightweight library for testing Solana Programs that works by creating an in-process Solana VM optimized for program developers. Unlike other testing approaches that spin up separate validator processes, LiteSVM embeds the VM inside your tests, making them execute much faster.

It handles the complexity of managing accounts, deploying programs, and processing transactions behind a simple API. The framework automatically manages blockchain state between transactions, so you don't need to manually track account changes or balances.

## Installation

<Tabs items={['Basic', 'With SPL Token Support']}>
<Tab value="Basic">
```bash
cargo add --dev litesvm
```
</Tab>

<Tab value="With SPL Token Support">
```bash
cargo add --dev litesvm
cargo add --dev litesvm-token
```
</Tab>
</Tabs>

## Basic Setup

### Create a Test Environment

```rust title="test.rs"
use litesvm::LiteSVM;

#[test]
fn test_basic_setup(){
    let mut svm = LiteSVM::new();
}
```

This creates the basic test environment with all runtime features enabled, default sysvars, precompiles, SPL programs, sigverify, and all built-in programs.

### Custom Configuration

```rust title="test.rs"
use litesvm::LiteSVM;
use solana_compute_budget::compute_budget::ComputeBudget;

#[test]
fn test_custom_config() {
    // Start from scratch and configure everything manually
    let mut svm = LiteSVM::default()
        .with_compute_budget(ComputeBudget {
            compute_unit_limit: 200_000,
            heap_size: 32_768,
            ..ComputeBudget::default()
        })
        .with_sigverify(false) // Disable signature verification
        .with_blockhash_check(false) // Enable blockhash checking
        .with_transaction_history(100) // Keep last 100 transactions
        .with_lamports(10_000_000_000_000); // 10,000 SOL for testing
}
```

## Deploying Programs

If your program CPIs into other programs, you'll need to deploy them to your test environment. The initial setup only includes built-in programs.

### Method 1: From File

```rust title="test.rs"
use litesvm::LiteSVM;
use solana_pubkey::Pubkey;

#[test]
fn test_deploy_from_file() {
    let mut svm = LiteSVM::new();

    // Deploy a program from a compiled .so file
    let program_id = Pubkey::new_unique();
    svm.add_program_from_file(
        program_id,
        "path/to/program.so"
    ).unwrap();

    // Program is now deployed and ready to use
}
```

### Method 2: From Bytes

```rust title="test.rs"
use litesvm::LiteSVM;
use solana_pubkey::Pubkey;

#[test]
fn test_deploy_from_bytes() {
    let mut svm = LiteSVM::new();

    // Include the program bytes at compile time
    let program_bytes = include_bytes!("../target/deploy/my_program.so");

    let program_id = Pubkey::new_unique();
    svm.add_program(program_id, program_bytes).unwrap();
}
```

### Method 3: From Cluster

Pull a program from any cluster, like the Pyth Oracle from devnet:

```bash title="Terminal"
# First, dump the program from mainnet
solana program dump <PROGRAM_ID> my_program.so --url devnet
```

```rust title="test.rs"
let pyth_mainnet_program_id = pubkey!("gSbePebfvPy7tRqimPoVecS2UsBvYv46ynrzWocc92s");
svm.add_program_from_file(pyth_mainnet_program_id, "my_program.so").unwrap();
```

## Sending Transactions

### Basic Transaction

```rust title="test.rs"
use litesvm::LiteSVM;
use solana_transaction::Transaction;
use solana_message::Message;
use solana_instruction::Instruction;
use solana_keypair::Keypair;
use solana_signer::Signer;
use solana_system_interface::instruction::transfer;

#[test]
fn test_basic_transaction() {
    let mut svm = LiteSVM::new();

    // Create accounts
    let sender = Keypair::new();
    let receiver = Keypair::new();

    // Fund the sender
    svm.airdrop(&sender.pubkey(), 1_000_000_000).unwrap(); // 1 SOL

    // Create a transfer instruction
    let instruction = transfer(
        &sender.pubkey(),
        &receiver.pubkey(),
        500_000_000, // 0.5 SOL
    );

    // Create and send transaction
    let tx = Transaction::new(
        &[&sender],
        Message::new(&[instruction], Some(&sender.pubkey())),
        svm.latest_blockhash(),
    );

    let result = svm.send_transaction(tx);

    // Check the result
    match result {
        Ok(meta) => {
            println!("Transaction successful!");
            println!("Compute units used: {}", meta.compute_units_consumed);
            println!("Logs: {:?}", meta.logs);
        }
        Err(e) => {
            println!("Transaction failed: {:?}", e);
        }
    }

    // Verify balances
    assert_eq!(svm.get_balance(&receiver.pubkey()).unwrap(), 500_000_000);
}
```

### Simulating Transactions

```rust title="test.rs"
use litesvm::LiteSVM;

#[test]
fn test_simulate_transaction() {
    let mut svm = LiteSVM::new();

    // ... setup transaction ...

    // Simulate without modifying state
    let sim_result = svm.simulate_transaction(transaction);

    match sim_result {
        Ok(info) => {
            println!("Simulation successful!");
            println!("Would consume {} compute units", info.meta.compute_units_consumed);
            // State is NOT modified
        }
        Err(e) => {
            println!("Simulation failed: {:?}", e.meta.logs);
        }
    }
}
```

## Working with Accounts

### Reading Accounts

```rust title="test.rs"
use litesvm::LiteSVM;
use solana_pubkey::Pubkey;

#[test]
fn test_read_accounts() {
    let svm = LiteSVM::new();
    let account_key = Pubkey::new_unique();

    // Get full account data
    if let Some(account) = svm.get_account(&account_key) {
        println!("Lamports: {}", account.lamports);
        println!("Owner: {}", account.owner);
        println!("Data length: {}", account.data.len());
        println!("Executable: {}", account.executable);
    }

    // Get just the balance
    if let Some(balance) = svm.get_balance(&account_key) {
        println!("Balance: {} lamports", balance);
    }
}
```

### Writing Arbitrary Accounts

<Callout type="info">
  LiteSVM allows you to create any account state, even if it wouldn't be possible in production.
</Callout>

```rust title="test.rs"
use litesvm::LiteSVM;
use solana_account::Account;
use solana_pubkey::Pubkey;
use spl_token::state::{Account as TokenAccount, AccountState};
use solana_program_option::COption;
use solana_program_pack::Pack;

#[test]
fn test_create_token_account() {
    let mut svm = LiteSVM::new();

    let owner = Pubkey::new_unique();
    let mint = Pubkey::new_unique();
    let token_account_key = Pubkey::new_unique();

    // Create a token account with 1 million tokens
    let token_account = TokenAccount {
        mint,
        owner,
        amount: 1_000_000_000_000,
        delegate: COption::None,
        state: AccountState::Initialized,
        is_native: COption::None,
        delegated_amount: 0,
        close_authority: COption::None,
    };

    let mut data = vec![0u8; TokenAccount::LEN];
    TokenAccount::pack(token_account, &mut data).unwrap();

    // Write the account
    svm.set_account(
        token_account_key,
        Account {
            lamports: 2_039_280, // Rent-exempt amount
            data,
            owner: spl_token::id(),
            executable: false,
            rent_epoch: 0,
        }
    ).unwrap();

    // Account is now available for testing!
}
```

### Airdropping Funds

```rust title="test.rs"
use litesvm::LiteSVM;
use solana_keypair::Keypair;
use solana_signer::Signer;

#[test]
fn test_airdrop() {
    let mut svm = LiteSVM::new();
    let user = Keypair::new();

    // Airdrop 10 SOL
    let result = svm.airdrop(&user.pubkey(), 10_000_000_000);

    assert!(result.is_ok());
    assert_eq!(svm.get_balance(&user.pubkey()).unwrap(), 10_000_000_000);
}
```

## Time Travel & Slot Manipulation

### Manipulating the Clock

```rust title="test.rs"
use litesvm::LiteSVM;
use solana_clock::Clock;

#[test]
fn test_time_travel() {
    let mut svm = LiteSVM::new();

    // Get current clock
    let mut clock: Clock = svm.get_sysvar();
    println!("Current slot: {}", clock.slot);
    println!("Current unix timestamp: {}", clock.unix_timestamp);

    // Jump to the future!
    clock.slot = 1000;
    clock.unix_timestamp = 1735689600; // Jan 1, 2025
    clock.epoch = 10;
    svm.set_sysvar(&clock);

    // Now any program that reads Clock will see the new time
}
```

### Warping to Slot

```rust title="test.rs"
use litesvm::LiteSVM;

#[test]
fn test_warp_to_slot() {
    let mut svm = LiteSVM::new();

    // Jump directly to slot 1000
    svm.warp_to_slot(1000);

    // Useful for testing time-locked features
}
```

### Expiring Blockhashes

```rust title="test.rs"
use litesvm::LiteSVM;

#[test]
fn test_expire_blockhash() {
    let mut svm = LiteSVM::new();

    let initial_blockhash = svm.latest_blockhash();

    // Expire the current blockhash
    svm.expire_blockhash();

    let new_blockhash = svm.latest_blockhash();
    assert_ne!(initial_blockhash, new_blockhash);

    // Old transactions will now fail with BlockhashNotFound
}
```

## Advanced Features

### Custom Sysvars

```rust title="test.rs"
use litesvm::LiteSVM;
use solana_rent::Rent;
use solana_epoch_schedule::EpochSchedule;

#[test]
fn test_custom_sysvars() {
    let mut svm = LiteSVM::new();

    // Set custom rent
    let rent = Rent {
        lamports_per_byte_year: 3480,
        exemption_threshold: 2.0,
        burn_percent: 50,
    };
    svm.set_sysvar(&rent);

    // Set custom epoch schedule
    let epoch_schedule = EpochSchedule {
        slots_per_epoch: 432_000,
        leader_schedule_slot_offset: 432_000,
        warmup: false,
        first_normal_epoch: 0,
        first_normal_slot: 0,
    };
    svm.set_sysvar(&epoch_schedule);
}
```

### Disabling Security Features

```rust title="test.rs"
use litesvm::LiteSVM;

#[test]
fn test_disable_security() {
    let mut svm = LiteSVM::default()
        .with_sigverify(false)       // Skip signature verification
        .with_blockhash_check(false) // Skip blockhash validation
        .with_transaction_history(0); // Allow duplicate transactions

    // Useful for testing edge cases and error conditions
}
```

### Transaction History

```rust title="test.rs"
use litesvm::LiteSVM;
use solana_signature::Signature;

#[test]
fn test_transaction_history() {
    let mut svm = LiteSVM::new()
        .with_transaction_history(100); // Keep last 100 transactions

    // ... send some transactions ...

    // Look up a previous transaction
    let signature = Signature::new_unique();
    if let Some(tx_result) = svm.get_transaction(&signature) {
        match tx_result {
            Ok(meta) => println!("Transaction found: {:?}", meta.logs),
            Err(e) => println!("Transaction failed: {:?}", e),
        }
    }
}
```

### Custom Compute Budget

```rust title="test.rs"
use litesvm::LiteSVM;
use solana_compute_budget::compute_budget::ComputeBudget;

#[test]
fn test_compute_budget() {
    let mut svm = LiteSVM::new()
        .with_compute_budget(ComputeBudget {
            compute_unit_limit: 1_400_000,
            heap_size: 256 * 1024, // 256KB heap
            stack_frame_size: 4096,
            log_pubkey_units: 100,
            ..ComputeBudget::default()
        });

    // Test compute-intensive operations
}
```

## Testing Best Practices

### 1. Use Helper Functions

```rust title="test.rs"
use litesvm::LiteSVM;
use solana_keypair::Keypair;
use solana_pubkey::Pubkey;
use solana_signer::Signer;

fn setup_test_environment() -> (LiteSVM, Keypair, Pubkey) {
    let mut svm = LiteSVM::new();
    let payer = Keypair::new();
    let program_id = Pubkey::new_unique();

    // Common setup
    svm.airdrop(&payer.pubkey(), 10_000_000_000).unwrap();
    svm.add_program_from_file(program_id, "program.so").unwrap();

    (svm, payer, program_id)
}

#[test]
fn test_something() {
    let (mut svm, payer, program_id) = setup_test_environment();
    // Your test here
}
```

### 2. Test Error Cases

```rust title="test.rs"
use litesvm::LiteSVM;

#[test]
fn test_insufficient_funds() {
    let mut svm = LiteSVM::new();

    // ... create transaction that requires more funds than available ...

    let result = svm.send_transaction(tx);
    assert!(result.is_err());

    if let Err(failed) = result {
        assert_eq!(failed.err, TransactionError::InsufficientFundsForFee);
        // Check logs for debugging info
        println!("Error logs: {:?}", failed.meta.logs);
    }
}
```

### 3. Snapshot Testing Pattern

```rust title="test.rs"
use litesvm::LiteSVM;

#[test]
fn test_complex_scenario() {
    let mut svm = LiteSVM::new();

    // Setup initial state
    setup_accounts(&mut svm);

    // Take snapshot of initial state
    let initial_balance = svm.get_balance(&account).unwrap();

    // Execute operations
    execute_program_logic(&mut svm);

    // Verify state changes
    let final_balance = svm.get_balance(&account).unwrap();
    assert_eq!(final_balance, initial_balance + expected_change);
}
```

## Common Patterns

### Testing PDA Derivation

```rust title="test.rs"
use litesvm::LiteSVM;
use solana_pubkey::Pubkey;

#[test]
fn test_pda() {
    let mut svm = LiteSVM::new();

    let program_id = Pubkey::new_unique();
    let seed = b"my_pda";

    let (pda, bump) = Pubkey::find_program_address(
        &[seed],
        &program_id
    );

    // Create an account at the PDA
    svm.set_account(pda, Account {
        lamports: 1_000_000,
        data: vec![bump], // Store bump seed
        owner: program_id,
        executable: false,
        rent_epoch: 0,
    }).unwrap();
}
```

### Testing Cross-Program Invocations (CPI)

```rust title="test.rs"
use litesvm::LiteSVM;

#[test]
fn test_cpi() {
    let mut svm = LiteSVM::new();

    // Deploy both programs
    let program_a = Pubkey::new_unique();
    let program_b = Pubkey::new_unique();

    svm.add_program_from_file(program_a, "program_a.so").unwrap();
    svm.add_program_from_file(program_b, "program_b.so").unwrap();

    // Create instruction that will CPI to program_b
    let instruction = Instruction {
        program_id: program_a,
        accounts: vec![
            AccountMeta::new(account_key, false),
            AccountMeta::new_readonly(program_b, false),
        ],
        data: instruction_data,
    };

    // Execute - CPI will work seamlessly
    let result = svm.send_transaction(tx);
}
```

### Testing with Real Mainnet Accounts

```rust title="test.rs"
use litesvm::LiteSVM;

#[test]
fn test_with_mainnet_state() {
    let mut svm = LiteSVM::new();

    // First, dump account from mainnet:
    // solana account <ADDRESS> --output json --url mainnet-beta > account.json

    // Load in test
    let account_data = std::fs::read_to_string("account.json").unwrap();
    let account: Account = serde_json::from_str(&account_data).unwrap();

    let address = pubkey!("YourMainnetAddress11111111111111111111111");
    svm.set_account(address, account).unwrap();

    // Test with real mainnet state
}
```

## Performance Tips

<Steps>
<Step>
  **Reuse SVM instances** when possible instead of creating new ones
</Step>
<Step>
  **Use simulate_transaction** for read-only operations
</Step>
<Step>
  **Disable unnecessary features** like signature verification in tests
</Step>
<Step>
  **Batch operations** when setting up complex state
</Step>
<Step>
  **Use include_bytes!** for programs to avoid runtime file I/O
</Step>
</Steps>

## Troubleshooting

### Common Issues and Solutions

<Callout type="error" title="Program not found">
  Ensure program is deployed before sending transactions:
  ```rust
  svm.add_program(program_id, &program_bytes)?;
  ```
</Callout>

<Callout type="error" title="Blockhash not found">
  Use the latest blockhash:
  ```rust
  let blockhash = svm.latest_blockhash();
  ```
</Callout>

<Callout type="error" title="Insufficient funds">
  Airdrop sufficient funds:
  ```rust
  svm.airdrop(&payer.pubkey(), 10_000_000_000)?;
  ```
</Callout>

<Callout type="error" title="Account not found">
  Create the account first:
  ```rust
  svm.set_account(address, account_data)?;
  ```
</Callout>

## Summary

LiteSVM provides a powerful, fast, and flexible testing environment for Solana programs. Its key strengths are:

- **Speed:** In-process execution eliminates network overhead
- **Control:** Direct manipulation of time, accounts, and state
- **Simplicity:** Intuitive API that gets out of your way
- **Flexibility:** Extensive configuration options for advanced scenarios

Start with `LiteSVM::new()` for most cases, and explore the advanced features as your testing needs grow more complex.

<Cards>
  <Card title="Documentation" href="/docs">
    Complete API reference and guides
  </Card>
  <Card title="GitHub" href="https://github.com/LiteSVM/litesvm">
    Source code and examples
  </Card>
  <Card title="Crates.io" href="https://crates.io/crates/litesvm">
    Install via cargo
  </Card>
</Cards>